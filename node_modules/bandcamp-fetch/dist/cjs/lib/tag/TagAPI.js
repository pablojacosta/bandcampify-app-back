"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimiterTagAPI = void 0;
const ImageAPI_1 = __importDefault(require("../image/ImageAPI"));
const Constants_1 = require("../utils/Constants");
const Fetch_1 = require("../utils/Fetch");
const Limiter_1 = __importDefault(require("../utils/Limiter"));
const Parse_1 = require("../utils/Parse");
const AlbumHighlightsByTagParser_1 = __importDefault(require("./AlbumHighlightsByTagParser"));
const ReleasesByTagParser_1 = __importDefault(require("./ReleasesByTagParser"));
const TagInfoParser_1 = __importDefault(require("./TagInfoParser"));
const TagListParser_1 = __importDefault(require("./TagListParser"));
class TagAPI {
    static async list() {
        const html = await (0, Fetch_1.fetchPage)((0, Parse_1.normalizeUrl)('tags'));
        return TagListParser_1.default.parseTags(html);
    }
    static async getInfo(tagUrl) {
        const html = await (0, Fetch_1.fetchPage)(tagUrl);
        return TagInfoParser_1.default.parseInfo(html, tagUrl);
    }
    static async getAlbumHighlights(params) {
        const imageConstants = await ImageAPI_1.default.getConstants();
        const opts = {
            imageBaseUrl: imageConstants.baseUrl,
            imageFormat: await ImageAPI_1.default.getFormat(params.imageFormat, 9)
        };
        const html = await (0, Fetch_1.fetchPage)(params.tagUrl);
        return AlbumHighlightsByTagParser_1.default.parseHighlights(html, opts);
    }
    static async getReleasesAvailableFilters(tagUrl) {
        const filterValueNames = await this.getReleaseFilterValueNames(tagUrl);
        const html = await (0, Fetch_1.fetchPage)(tagUrl);
        return ReleasesByTagParser_1.default.parseFilters(html, filterValueNames);
    }
    static async getReleases(params) {
        const imageConstants = await ImageAPI_1.default.getConstants();
        const opts = {
            imageBaseUrl: imageConstants.baseUrl,
            imageFormat: await ImageAPI_1.default.getFormat(params.imageFormat, 9)
        };
        const _getDefaultFilters = async (tagUrl) => {
            if (params.useHardcodedDefaultFilters) {
                let tagUrlPath = (0, Parse_1.splitUrl)(tagUrl).path;
                if (tagUrlPath.endsWith('/')) {
                    tagUrlPath = tagUrlPath.substring(0, tagUrlPath.length - 1);
                }
                const tagValue = tagUrlPath.split('/').pop();
                return Promise.resolve({
                    tags: [tagValue],
                    location: 0,
                    format: 'all',
                    sort: 'pop'
                });
            }
            const filterOptions = await this.getReleasesAvailableFilters(tagUrl);
            const defaultFilters = {};
            filterOptions.forEach((filter) => {
                const selectedOption = filter.options.find((o) => o.selected);
                const defaultOption = filter.options.find((o) => o.default);
                if (selectedOption) {
                    if (filter.name === 'tags') {
                        defaultFilters[filter.name] = [selectedOption.value];
                    }
                    else {
                        defaultFilters[filter.name] = selectedOption.value;
                    }
                }
                else if (defaultOption) {
                    defaultFilters[filter.name] = defaultOption.value;
                }
            });
            return defaultFilters;
        };
        const defaultFilters = await _getDefaultFilters(params.tagUrl);
        const tagsFilter = Array.isArray(defaultFilters.tags) ? [...defaultFilters.tags] : [];
        if (params?.filters?.tags && Array.isArray(params.filters.tags)) {
            params.filters.tags.forEach((tag) => {
                if (!tagsFilter.includes(tag)) {
                    tagsFilter.push(tag);
                }
            });
        }
        const paramFilters = params.filters ? {
            ...defaultFilters,
            ...params.filters,
            tags: tagsFilter
        } : defaultFilters;
        const postData = {
            filters: paramFilters,
            page: params.page || 1
        };
        const json = await (0, Fetch_1.fetchPage)(Constants_1.URLS.DIG_DEEPER, true, Fetch_1.FetchMethod.POST, postData);
        return ReleasesByTagParser_1.default.parseReleases(json, opts);
    }
    /**
     * @internal
     */
    static async getReleaseFilterValueNames(tagUrl) {
        const url = `${tagUrl}?tab=all_releases`;
        const html = await (0, Fetch_1.fetchPage)(url);
        const path = ReleasesByTagParser_1.default.parseHubJSPath(html);
        if (!path) {
            throw new Parse_1.ParseError(`Failed to obtain Hub JS path from ${url}`, html);
        }
        const js = await (0, Fetch_1.fetchPage)(path);
        try {
            return ReleasesByTagParser_1.default.parseHubJSFilterValueNames(js);
        }
        catch (error) {
            throw new Parse_1.ParseError('Failed to obtain filter names / values from Hub JS', js, error);
        }
    }
}
exports.default = TagAPI;
class LimiterTagAPI extends TagAPI {
    static async list() {
        return Limiter_1.default.schedule(() => super.list());
    }
    static async getInfo(tagUrl) {
        return Limiter_1.default.schedule(() => super.getInfo(tagUrl));
    }
    static async getAlbumHighlights(params) {
        return Limiter_1.default.schedule(() => super.getAlbumHighlights(params));
    }
    static async getReleasesAvailableFilters(tagUrl) {
        return Limiter_1.default.schedule(() => super.getReleasesAvailableFilters(tagUrl));
    }
    static async getReleases(params) {
        return Limiter_1.default.schedule(() => super.getReleases(params));
    }
}
exports.LimiterTagAPI = LimiterTagAPI;
//# sourceMappingURL=TagAPI.js.map