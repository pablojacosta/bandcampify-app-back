import { load as cheerioLoad } from 'cheerio';
import { decode } from 'html-entities';
import { ParseError, stripLineBreaks } from '../utils/Parse';
import { Interpreter } from 'eval5';
export default class ReleasesByTagParser {
    static parseHubJSPath(html) {
        const jsMatch = (/src="((?:.+?)hub-(?:.+?).js)"/g).exec(html);
        return jsMatch?.[1] || null;
    }
    static parseHubJSFilterValueNames(js) {
        const filterValueNames = {};
        const tObj = (/"hubs\/digdeeper\/filter_value":(.+?)}\),/gs).exec(js);
        if (tObj?.[1]) {
            const interpreter = new Interpreter({});
            const t = interpreter.evaluate(tObj[1]);
            if (Array.isArray(t?.[0]?.blocks)) {
                const _getValFromBlockAttachment = (attachment) => {
                    if (attachment?.type === 'translate' && attachment?.nodelist?.[0] !== undefined) {
                        return stripLineBreaks(attachment.nodelist[0]).trim();
                    }
                    else if (typeof attachment === 'string') {
                        return stripLineBreaks(attachment).trim();
                    }
                    return '';
                };
                t[0].blocks.forEach((filterBlock) => {
                    const filterName = interpreter.evaluate(filterBlock.expression?.split('==')[1]);
                    if (filterName && Array.isArray(filterBlock.attachment)) {
                        filterBlock
                            .attachment.find((a) => Array.isArray(a?.blocks))
                            .blocks.filter((block) => block?.expression)
                            .forEach((valueBlock) => {
                            const value = interpreter.evaluate(valueBlock.expression?.split('==')[1]);
                            if (value != null && Array.isArray(valueBlock?.attachment)) {
                                const valueName = valueBlock.attachment.reduce((a, c) => {
                                    const cVal = stripLineBreaks(_getValFromBlockAttachment(c)).trim();
                                    if (cVal !== '') {
                                        return a !== '' ? `${a} ${cVal}` : cVal;
                                    }
                                    return a;
                                }, '');
                                //Console.log('value name: ' + valueName);
                                if (valueName) {
                                    if (!filterValueNames[filterName]) {
                                        filterValueNames[filterName] = {};
                                    }
                                    filterValueNames[filterName][value] = valueName;
                                }
                            }
                        });
                    }
                });
            }
        }
        return filterValueNames;
    }
    static parseFilters(html, filterValueNames) {
        const $ = cheerioLoad(html);
        const blob = decode($('#pagedata[data-blob]').attr('data-blob'));
        const parsed = JSON.parse(blob);
        const filters = [];
        if (typeof parsed === 'object' && parsed.hub && Array.isArray(parsed.hub.tabs)) {
            const tab = parsed.hub.tabs[1]; // All releases
            const _setOrAdd = (f, t, prop) => {
                const target = f.options.find((f) => f.value === t.value);
                if (target) {
                    target[prop] = true;
                }
                else if (t.value && t.name) {
                    const tAdd = {
                        name: t.name,
                        value: t.value
                    };
                    tAdd[prop] = true;
                    f.options.push(tAdd);
                }
            };
            if (tab && tab.dig_deeper && typeof tab.dig_deeper.filters === 'object') {
                const filterKeys = Object.keys(tab.dig_deeper.filters);
                filterKeys.forEach((filterName) => {
                    const filter = {
                        name: filterName,
                        options: []
                    };
                    const filterData = tab.dig_deeper.filters[filterName];
                    if (Array.isArray(filterData?.options)) {
                        filterData.options.forEach((filterOption) => {
                            const valueName = filterValueNames?.[filterName]?.[filterOption?.value] || filterOption?.name || filterOption?.value;
                            if (valueName) {
                                filter.options.push({
                                    name: valueName,
                                    value: filterOption.value
                                });
                            }
                        });
                    }
                    if (typeof filterData?.selected === 'object' && !Array.isArray(filterData.selected)) {
                        _setOrAdd(filter, filterData.selected, 'selected');
                    }
                    else if (Array.isArray(filterData?.selected)) {
                        filterData.selected.forEach((s) => {
                            _setOrAdd(filter, s, 'selected');
                        });
                    }
                    if (filterData?.default) {
                        _setOrAdd(filter, filterData.default, 'default');
                    }
                    filters.push(filter);
                });
            }
        }
        return filters;
    }
    static parseReleases(json, opts) {
        if (typeof json === 'object' && Array.isArray(json.items)) {
            const parsedItems = [];
            json.items.forEach((item) => {
                let mediaItemType;
                switch (item.item_type) {
                    case 'a':
                        mediaItemType = 'album';
                        break;
                    case 't':
                        mediaItemType = 'track';
                        break;
                    default:
                        mediaItemType = null;
                }
                if (mediaItemType) {
                    const mediaItem = {
                        type: mediaItemType,
                        name: item.title,
                        url: item.tralbum_url,
                        imageUrl: '',
                        genre: item.genre,
                        artist: {
                            name: item.artist,
                            url: item.band_url
                        }
                    };
                    if (item.art_id && opts.imageFormat?.id) {
                        mediaItem.imageUrl = `${opts.imageBaseUrl}/img/a${item.art_id}_${opts.imageFormat.id}.jpg`;
                    }
                    if (mediaItemType === 'album' && item.featured_track_title) {
                        const album = mediaItem;
                        album.featuredTrack = {
                            name: item.featured_track_title,
                            position: item.featured_track_number,
                            streamUrl: item.audio_url?.['mp3-128']
                        };
                    }
                    else if (mediaItemType === 'track') {
                        mediaItem.streamUrl = item.audio_url?.['mp3-128'];
                    }
                    parsedItems.push(mediaItem);
                }
            });
            return {
                items: parsedItems,
                hasMore: json.more_available,
                filters: JSON.parse(json.filters)
            };
        }
        throw new ParseError('Failed to parse releases by tag: invalid JSON data', json);
    }
}
//# sourceMappingURL=ReleasesByTagParser.js.map