import { URL } from 'url';
import ImageAPI from '../image/ImageAPI';
import { URLS } from '../utils/Constants';
import { fetchPage } from '../utils/Fetch';
import SearchResultsParser from './SearchResultsParser';
import Limiter from '../utils/Limiter';
export var SearchItemType;
(function (SearchItemType) {
    SearchItemType["All"] = "All";
    SearchItemType["ArtistsAndLabels"] = "ArtistsAndLabels";
    SearchItemType["Albums"] = "Albums";
    SearchItemType["Tracks"] = "Tracks";
    SearchItemType["Fans"] = "Fans";
})(SearchItemType || (SearchItemType = {}));
export default class SearchAPI {
    static async all(params) {
        return this.search({ ...params, itemType: SearchItemType.All });
    }
    static async artistsAndLabels(params) {
        return this.search({ ...params, itemType: SearchItemType.ArtistsAndLabels });
    }
    static async albums(params) {
        return this.search({ ...params, itemType: SearchItemType.Albums });
    }
    static async tracks(params) {
        return this.search({ ...params, itemType: SearchItemType.Tracks });
    }
    static async fans(params) {
        return this.search({ ...params, itemType: SearchItemType.Fans });
    }
    static async search(params) {
        const opts = {
            itemType: params.itemType || SearchItemType.All,
            albumImageFormat: await ImageAPI.getFormat(params.albumImageFormat, 9),
            artistImageFormat: await ImageAPI.getFormat(params.artistImageFormat, 21)
        };
        const html = await fetchPage(this.getSearchUrl(params));
        return SearchResultsParser.parseResults(html, opts);
    }
    /**
     * @internal
     */
    static getSearchUrl(params) {
        const urlObj = new URL(URLS.SEARCH);
        urlObj.searchParams.set('q', params.query);
        urlObj.searchParams.set('page', (params.page || 1).toString());
        switch (params.itemType) {
            case SearchItemType.ArtistsAndLabels:
                urlObj.searchParams.set('item_type', 'b');
                break;
            case SearchItemType.Albums:
                urlObj.searchParams.set('item_type', 'a');
                break;
            case SearchItemType.Tracks:
                urlObj.searchParams.set('item_type', 't');
                break;
            case SearchItemType.Fans:
                urlObj.searchParams.set('item_type', 'f');
                break;
            default:
        }
        return urlObj.toString();
    }
}
export class LimiterSearchAPI extends SearchAPI {
    static async all(params) {
        return Limiter.schedule(() => super.all(params));
    }
    static async artistsAndLabels(params) {
        return Limiter.schedule(() => super.artistsAndLabels(params));
    }
    static async albums(params) {
        return Limiter.schedule(() => super.albums(params));
    }
    static async tracks(params) {
        return Limiter.schedule(() => super.tracks(params));
    }
    static async fans(params) {
        return Limiter.schedule(() => super.fans(params));
    }
}
//# sourceMappingURL=SearchAPI.js.map