"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimiterDiscoveryAPI = void 0;
const ImageAPI_1 = __importDefault(require("../image/ImageAPI"));
const Cache_1 = require("../utils/Cache");
const Constants_1 = require("../utils/Constants");
const Fetch_1 = require("../utils/Fetch");
const Limiter_1 = __importDefault(require("../utils/Limiter"));
const DiscoverOptionsParser_1 = __importDefault(require("./DiscoverOptionsParser"));
const DiscoverResultParser_1 = __importDefault(require("./DiscoverResultParser"));
class DiscoveryAPI {
    static async getAvailableOptions() {
        return Cache_1.Cache.getOrSet(Cache_1.CacheDataType.Constants, 'discoverOptions', async () => {
            const html = await (0, Fetch_1.fetchPage)(Constants_1.URLS.SITE_URL);
            return DiscoverOptionsParser_1.default.parseOptions(html);
        });
    }
    static async sanitizeDiscoverParams(params) {
        const options = await this.getAvailableOptions();
        const _getOptionValue = (optArr, value, defaultIndex = 0) => {
            if (value !== undefined && optArr) {
                const opt = optArr.find((o) => o.value == value);
                if (opt) {
                    return opt.value;
                }
            }
            if (optArr) {
                return optArr[defaultIndex].value;
            }
            return undefined;
        };
        const sanitized = {
            genre: _getOptionValue(options.genres, params?.genre),
            sortBy: _getOptionValue(options.sortBys, params?.sortBy),
            page: params?.page || 0
        };
        if (sanitized.sortBy !== 'rec' && sanitized.genre) {
            // Following only available when sortBy is not 'rec' (artist-recommend)
            const subgenreOptions = options.subgenres[sanitized.genre];
            if (subgenreOptions) { // `false` if genre is 'all'
                sanitized.subgenre = _getOptionValue(subgenreOptions, params?.subgenre);
            }
            // 'Time' option only available when there is effectively no subgenre (e.g. genre is 'all' or subgenre is 'all-metal')
            const timeAllowed = sanitized.subgenre === undefined || sanitized.subgenre == subgenreOptions[0].value;
            if (timeAllowed) {
                sanitized.time = _getOptionValue(options.times, params?.time, 1);
            }
            sanitized.location = _getOptionValue(options.locations, params?.location);
            sanitized.format = _getOptionValue(options.formats, params?.format);
        }
        else {
            sanitized.artistRecommendationType = _getOptionValue(options.artistRecommendationTypes, params?.artistRecommendationType);
        }
        return sanitized;
    }
    static async discover(params) {
        const imageConstants = await ImageAPI_1.default.getConstants();
        const opts = {
            imageBaseUrl: imageConstants.baseUrl,
            albumImageFormat: await ImageAPI_1.default.getFormat(params?.albumImageFormat, 9),
            artistImageFormat: await ImageAPI_1.default.getFormat(params?.artistImageFormat, 21)
        };
        const sanitizedParams = await this.sanitizeDiscoverParams(params);
        const resultParams = { ...sanitizedParams };
        // Passing an 'all' type subgenre (e.g. 'all-metal') in the discover url
        // Actually returns far fewer / zero results than without.
        // The Bandcamp site also does not seem to include it in its discover requests...
        if (sanitizedParams.time !== undefined) {
            // If 'time' exists in sanitized params, then we have an 'all' type subgenre
            // - refer to sanitizeDiscoverParams()
            delete sanitizedParams.subgenre;
        }
        const payload = this.getDiscoverRequestPayload(sanitizedParams);
        const json = await (0, Fetch_1.fetchPage)(Constants_1.URLS.DISCOVER_URL, true, Fetch_1.FetchMethod.GET, payload);
        return DiscoverResultParser_1.default.parseDiscoverResult(json, opts, resultParams);
    }
    /**
     * @internal
     */
    static getDiscoverRequestPayload(params) {
        const result = {
            s: params.sortBy || 'top',
            p: params.page || 0
        };
        if (params.genre) {
            result.g = params.genre;
            if (params.subgenre) {
                result.t = params.subgenre;
            }
        }
        if (params.location !== undefined) {
            result.gn = params.location;
        }
        if (params.format) {
            result.f = params.format;
        }
        if (result.s === 'rec' && params.artistRecommendationType) {
            result.r = params.artistRecommendationType;
        }
        if (params.time !== undefined) {
            result.w = params.time;
        }
        return result;
    }
}
exports.default = DiscoveryAPI;
class LimiterDiscoveryAPI extends DiscoveryAPI {
    static async getAvailableOptions() {
        return Limiter_1.default.schedule(() => super.getAvailableOptions());
    }
    static async sanitizeDiscoverParams(params) {
        return Limiter_1.default.schedule(() => super.sanitizeDiscoverParams(params));
    }
    static async discover(params) {
        return Limiter_1.default.schedule(() => super.discover(params));
    }
}
exports.LimiterDiscoveryAPI = LimiterDiscoveryAPI;
//# sourceMappingURL=DiscoveryAPI.js.map